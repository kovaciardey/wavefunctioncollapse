using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

/**
 * This class is used to save the data generated by the input processor to a JSON file.
 * It uses an intermediary class to translate the objects from a WfcGenerationData instance into a serializable manner
 */
public class WaveFunctionDataSaver
{
    /**
     * Intermediate class for the WfcGenerationData instance to be properly serialized
     */
    [System.Serializable]
    private class WfcDataWrapper
    {
        public int totalPixels;
        public List<string> tileHashes = new List<string>();
        public List<TileData> tileDataList = new List<TileData>();
        public List<TilePair> tilePairs = new List<TilePair>();
        
        
        [System.Serializable]
        public class TileData
        {
            public string hash;
            public string colorValue;
            public int occurrences;
            public float weight; 
            public List<TileDirectionNeighbors> allowedNeighbors;
        }
        
        [System.Serializable]
        public class TilePair
        {
            public string tile;
            public string neighbor;
            public string direction;
        }
        
        [System.Serializable]
        public class TileDirectionNeighbors
        {
            public string direction;
            public List<string> neighbors;
        }

        public WfcDataWrapper(WfcGenerationData data)
        {
            totalPixels = data.TotalPixels;

            foreach (string tileHash in data.TileHashes)
            {
                tileHashes.Add(tileHash);

                TileData tileData = new TileData()
                {
                    hash = tileHash,
                    colorValue = CustomUtils.ColorToHex(data.TileMap[tileHash]),
                    occurrences = data.TileCounts[tileHash],
                    weight = data.TileWeights[tileHash],
                    allowedNeighbors = new List<TileDirectionNeighbors>()
                };

                foreach (KeyValuePair<string,List<string>> kvp in data.TileNeighborsAlternate[tileHash])
                {
                    TileDirectionNeighbors tileDirectionNeighbors = new TileDirectionNeighbors
                    {
                        direction = kvp.Key,
                        neighbors = kvp.Value
                    };
                    
                    tileData.allowedNeighbors.Add(tileDirectionNeighbors);
                }
                
                tileDataList.Add(tileData);
            }
            
            foreach (Tuple<string,string,string> pair in data.TileNeighbors)
            {
                tilePairs.Add(new TilePair
                {
                    tile = pair.Item1,
                    neighbor = pair.Item2,
                    direction = pair.Item3
                });
            }
        }
    }
    
    /**
     * Save the serialized WfcGenerationData to a JSON file named the same as the input image
     */
    public static void SaveToJson(WfcGenerationData data, string fileName)
    {
        string json = JsonUtility.ToJson(new WfcDataWrapper(data), true); // Pretty print

        string path = Path.Combine(Application.dataPath, "Resources", fileName + ".json");

        File.WriteAllText(path, json);
        Debug.Log("Saved JSON to: " + path);
    }

    /**
     * Load a JSON file and create and return a WfcGenerationData instance
     */
    public static WfcGenerationData LoadFromJson(string fileName)
    {
        TextAsset jsonFile = Resources.Load<TextAsset>(fileName);
        if (jsonFile == null)
        {
            Debug.LogError("File not found: " + fileName);
            return null;
        }
        
        Debug.Log(jsonFile.text);

        WfcDataWrapper wrapper = JsonUtility.FromJson<WfcDataWrapper>(jsonFile.text);
        var data = new WfcGenerationData
        {
            TotalPixels = wrapper.totalPixels,
            TileHashes = new HashSet<string>(),
            TileMap = new Dictionary<string, Color>(),
            TileCounts = new Dictionary<string, int>(),
            TileWeights = new Dictionary<string, float>(),
            TileNeighbors = new HashSet<Tuple<string, string, string>>(),
            // TODO: skipping the alternate neighbours data structure for now
        };
        
        // Create the TileHashes hashset and the dictionaries
        foreach (string entry in wrapper.tileHashes)
        {
            data.TileHashes.Add(entry);
            
            Debug.Log(entry);
            Debug.Log(wrapper.tileDataList.Count);

            // In theory this should always return a value, but I could do some better null checking
            WfcDataWrapper.TileData tileData = wrapper.tileDataList.First(tile => tile.hash == entry);

            data.TileMap.Add(entry, CustomUtils.HexToColor(tileData.colorValue));
            data.TileCounts.Add(entry, tileData.occurrences);
            data.TileWeights.Add(entry, tileData.weight);
        }
        
        // Create the 3-Tuple hashset
        foreach (WfcDataWrapper.TilePair pair in wrapper.tilePairs)
        {
            data.TileNeighbors.Add(new Tuple<string, string, string>(pair.tile, pair.neighbor, pair.direction));
        }

        return data;
    }
}